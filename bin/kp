#!/bin/bash
# pk - interactive process killer using fzf

# Parse args
ALL=false
[[ "$1" == "--all" || "$1" == "-a" ]] && ALL=true

# Build ps command: PID, CPU, MEM, START, ARGS
if $ALL; then
  PS_CMD="ps ax -o pid,pcpu,pmem,start,args"
else
  PS_CMD="ps x -o pid,pcpu,pmem,start,args"
fi

# Colorize and extract smart name
colorize() {
  awk '
NR==1 {
  printf "\033[1;37m%7s %5s %5s %8s  %-25s %s\033[0m\n", "PID", "%CPU", "%MEM", "START", "NAME", "COMMAND"
  next
}
{
  pid=$1; cpu=$2; mem=$3; start=$4

  # Full args for display
  args=""
  for(i=5;i<=NF;i++) args = args $i " "

  # Smart name: skip shells/interpreters, find real command
  name = ""
  for(i=5; i<=NF; i++) {
    n = split($i, parts, "/")
    base = parts[n]

    # Skip shells and interpreters
    skip = 0
    if (base == "sh") skip = 1
    if (base == "bash") skip = 1
    if (base == "zsh") skip = 1
    if (base == "fish") skip = 1
    if (base == "node") skip = 1
    if (base == "python") skip = 1
    if (base == "python3") skip = 1
    if (base == "ruby") skip = 1
    if (base == "perl") skip = 1
    if (base == "tclsh") skip = 1
    if (base == "unbuffer") skip = 1
    if (base == "expect") skip = 1
    if (base == "env") skip = 1
    if (substr($i, 1, 1) == "-") skip = 1

    if (skip == 1) continue

    # Found real command - take basename plus remaining args
    for(j=i; j<=NF; j++) {
      nn = split($j, pp, "/")
      name = name pp[nn] " "
    }
    break
  }

  # Fallback to basename of first arg
  if (name == "") {
    n = split($5, parts, "/")
    name = parts[n]
  }

  # Trim trailing space
  gsub(/ +$/, "", name)

  printf "\033[36m%7s\033[0m \033[33m%5s %5s\033[0m \033[37m%8s\033[0m  \033[97m%-25s\033[0m \033[90m%s\033[0m\n", pid, cpu, mem, start, name, args
}
'
}

# Preview script
PREVIEW='
  pid={1}
  info=$(ps -p $pid -o user,%cpu,%mem,start,command 2>/dev/null | tail -1)
  user=$(echo "$info" | awk "{print \$1}")
  cpu=$(echo "$info" | awk "{print \$2}")
  mem=$(echo "$info" | awk "{print \$3}")
  start=$(echo "$info" | awk "{print \$4}")
  cmd=$(echo "$info" | awk "{for(i=5;i<=NF;i++) printf \"%s \", \$i; print \"\"}")

  echo -e "\033[1;36mPID\033[0m"
  echo "$pid"
  echo ""
  echo -e "\033[1;36mUser\033[0m"
  echo "$user"
  echo ""
  echo -e "\033[1;36mCPU %\033[0m"
  echo "$cpu"
  echo ""
  echo -e "\033[1;36mMemory %\033[0m"
  echo "$mem"
  echo ""
  echo -e "\033[1;36mStarted\033[0m"
  echo "$start"
  echo ""
  echo -e "\033[1;36mCommand\033[0m"
  echo "$cmd"
  echo ""
  echo -e "\033[1;36mOpen Ports\033[0m"
  lsof -i -P -n 2>/dev/null | grep "^[^ ]*[ ]*$pid " | awk "{print \$9}" || echo "None"
'

# Run fzf
selected=$($PS_CMD | colorize | \
  fzf --ansi \
      --multi \
      --layout=reverse \
      --height=40% \
      --no-hscroll \
      --header="enter: kill | ctrl-k: force kill | tab: multi-select" \
      --expect=ctrl-k \
      --preview="$PREVIEW" \
      --preview-window=right:40%:wrap \
      --header-lines=1)

# Parse output
key=$(echo "$selected" | head -1)
pids=$(echo "$selected" | tail -n +2 | awk '{print $1}')

[[ -z "$pids" ]] && exit 0

# Kill with appropriate signal
if [[ "$key" == "ctrl-k" ]]; then
  echo "$pids" | xargs kill -9
  echo "Force killed: $pids"
else
  echo "$pids" | xargs kill
  echo "Killed: $pids"
fi
